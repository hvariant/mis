./cs/csmds.c:	eptr->sock = msock;
./cs/csmds.c:	eptr->pdescpos = -1;
./cs/csmds.c:  eptr->peerip = mdsip;
./cs/csmds.c:  eptr->mode = HEADER;
./cs/csmds.c:  eptr->inpacket = NULL;
./cs/csmds.c:  eptr->bytesleft = HEADER_LEN;
./cs/csmds.c:  eptr->startptr = eptr->headbuf;
./cs/csmds.c:  eptr->outpacket = regp;
./cs/csmds.c:  if (eptr->pdescpos>=0) {
./cs/csmds.c:    if (pdesc[eptr->pdescpos].revents & (POLLERR|POLLHUP)) {
./cs/csmds.c:      eptr->mode = KILL;
./cs/csmds.c:    if ((pdesc[eptr->pdescpos].revents & POLLIN) && eptr->mode!=KILL) {
./cs/csmds.c:  if (eptr->pdescpos>=0) {
./cs/csmds.c:    if ((((pdesc[eptr->pdescpos].events & POLLOUT)==0 && (eptr->outpacket!=NULL)) || (pdesc[eptr->pdescpos].revents & POLLOUT)) && eptr->mode!=KILL) {
./cs/csmds.c:  pdesc[pos].fd = eptr->sock;
./cs/csmds.c:  eptr->pdescpos = pos;
./cs/csmds.c:  if (eptr->outpacket != NULL) {
./cs/csmds.c:  for( pp = eptr->inpacket; pp; pp = ppn){
./cs/csmds.c:  for( pp = eptr->outpacket; pp; pp = ppn){
./cs/csmds.c:    if(eptr->mode == HEADER){
./cs/csmds.c:		  i=read(eptr->sock,eptr->startptr,eptr->bytesleft);
./cs/csmds.c:      i=read(eptr->sock,eptr->inpacket->startptr,eptr->inpacket->bytesleft);
./cs/csmds.c:      fprintf(stderr,"connection with mds(ip:%u.%u.%u.%u) has been closed by peer\n",(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./cs/csmds.c:			eptr->mode = KILL;
./cs/csmds.c:				eptr->mode = KILL;
./cs/csmds.c:    fprintf(stderr,"read %d from (ip:%u.%u.%u.%u)\n",i,(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./cs/csmds.c:    if(eptr->mode == HEADER){
./cs/csmds.c:      eptr->bytesleft -= i;
./cs/csmds.c:      eptr->startptr += i;
./cs/csmds.c:      if(eptr->bytesleft > 0) return;
./cs/csmds.c:      const uint8_t *pptr = eptr->headbuf;
./cs/csmds.c:      id = eptr->peerip;
./cs/csmds.c:      inp->next = eptr->inpacket;
./cs/csmds.c:      eptr->inpacket = inp;
./cs/csmds.c:      eptr->mode = DATA;
./cs/csmds.c:      eptr->inpacket->bytesleft -= i;
./cs/csmds.c:      eptr->inpacket->startptr += i;
./cs/csmds.c:      if(eptr->inpacket->bytesleft > 0) return;
./cs/csmds.c:      eptr->inpacket->startptr = eptr->inpacket->buf;
./cs/csmds.c:      fprintf(stderr,"packet received,size=%d,cmd=%X,id=%d\n",eptr->inpacket->size,eptr->inpacket->cmd,eptr->inpacket->id);
./cs/csmds.c:      csmds_gotpacket(eptr,eptr->inpacket);
./cs/csmds.c:      ppacket* p = eptr->inpacket;
./cs/csmds.c:      eptr->inpacket = eptr->inpacket->next;
./cs/csmds.c:      if(eptr->inpacket == NULL){
./cs/csmds.c:        eptr->mode = HEADER;
./cs/csmds.c:        eptr->startptr = eptr->headbuf;
./cs/csmds.c:        eptr->bytesleft = HEADER_LEN;
./cs/csmds.c:  while(eptr->outpacket){
./cs/csmds.c:		i=write(eptr->sock,eptr->outpacket->startptr,eptr->outpacket->bytesleft);
./cs/csmds.c:				mfs_arg_errlog_silent(LOG_NOTICE,"csmds: (ip:%u.%u.%u.%u) write error",(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./cs/csmds.c:				eptr->mode = KILL;
./cs/csmds.c:    fprintf(stderr,"wrote %d to (ip:%u.%u.%u.%u)\n",i,(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./cs/csmds.c:		eptr->outpacket->startptr += i;
./cs/csmds.c:		eptr->outpacket->bytesleft -=i;
./cs/csmds.c:    if(eptr->outpacket->bytesleft > 0) return;
./cs/csmds.c:    ppacket* p = eptr->outpacket;
./cs/csmds.c:    eptr->outpacket = eptr->outpacket->next;
./cs/csmds.c:  outp->next = eptr->outpacket;
./cs/csmds.c:  eptr->outpacket = outp;
./cs/cscl.c:			eptr->next = csclservhead;
./cs/cscl.c:			eptr->sock = ns;
./cs/cscl.c:			eptr->pdescpos = -1;
./cs/cscl.c:			tcpgetpeer(ns,&(eptr->peerip),NULL);
./cs/cscl.c:			eptr->mode = HEADER;
./cs/cscl.c:      eptr->inpacket = NULL;
./cs/cscl.c:      eptr->outpacket = NULL;
./cs/cscl.c:      eptr->bytesleft = HEADER_LEN;
./cs/cscl.c:      eptr->startptr = eptr->headbuf;
./cs/cscl.c:      fprintf(stderr,"client (ip:%u.%u.%u.%u) connected\n",(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./cs/cscl.c:	for (eptr=csclservhead ; eptr ; eptr=eptr->next) {
./cs/cscl.c:		if (eptr->pdescpos>=0) {
./cs/cscl.c:			if (pdesc[eptr->pdescpos].revents & (POLLERR|POLLHUP)) {
./cs/cscl.c:				eptr->mode = KILL;
./cs/cscl.c:			if ((pdesc[eptr->pdescpos].revents & POLLIN) && eptr->mode!=KILL) {
./cs/cscl.c:	for (eptr=csclservhead ; eptr ; eptr=eptr->next) {
./cs/cscl.c:		if (eptr->pdescpos>=0) {
./cs/cscl.c:			if ((((pdesc[eptr->pdescpos].events & POLLOUT)==0 && (eptr->outpacket!=NULL)) || (pdesc[eptr->pdescpos].revents & POLLOUT)) && eptr->mode!=KILL) {
./cs/cscl.c:		if (eptr->mode == KILL) {
./cs/cscl.c:			tcpclose(eptr->sock);
./cs/cscl.c:			*kptr = eptr->next;
./cs/cscl.c:			kptr = &(eptr->next);
./cs/cscl.c:	for(eptr=csclservhead ; eptr ; eptr=eptr->next){
./cs/cscl.c:		pdesc[pos].fd = eptr->sock;
./cs/cscl.c:		eptr->pdescpos = pos;
./cs/cscl.c:		if (eptr->outpacket != NULL) {
./cs/cscl.c:		eptrn = eptr->next;
./cs/cscl.c:    for( pp = eptr->inpacket; pp; pp = ppn){
./cs/cscl.c:    for( pp = eptr->outpacket; pp; pp = ppn){
./cs/cscl.c:    if(eptr->mode == HEADER){
./cs/cscl.c:		  i=read(eptr->sock,eptr->startptr,eptr->bytesleft);
./cs/cscl.c:      i=read(eptr->sock,eptr->inpacket->startptr,eptr->inpacket->bytesleft);
./cs/cscl.c:      fprintf(stderr,"connection with client(ip:%u.%u.%u.%u) has been closed by peer\n",(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./cs/cscl.c:			eptr->mode = KILL;
./cs/cscl.c:				eptr->mode = KILL;
./cs/cscl.c:    fprintf(stderr,"read %d from (ip:%u.%u.%u.%u)\n",i,(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./cs/cscl.c:    if(eptr->mode == HEADER){
./cs/cscl.c:      eptr->bytesleft -= i;
./cs/cscl.c:      eptr->startptr += i;
./cs/cscl.c:      if(eptr->bytesleft > 0) return;
./cs/cscl.c:      const uint8_t *pptr = eptr->headbuf;
./cs/cscl.c:      inp->next = eptr->inpacket;
./cs/cscl.c:      eptr->inpacket = inp;
./cs/cscl.c:      eptr->mode = DATA;
./cs/cscl.c:      eptr->inpacket->bytesleft -= i;
./cs/cscl.c:      eptr->inpacket->startptr += i;
./cs/cscl.c:      if(eptr->inpacket->bytesleft > 0) return;
./cs/cscl.c:      eptr->inpacket->startptr = eptr->inpacket->buf;
./cs/cscl.c:      fprintf(stderr,"packet received,size=%d,cmd=%X\n",eptr->inpacket->size,eptr->inpacket->cmd);
./cs/cscl.c:      cscl_gotpacket(eptr,eptr->inpacket);
./cs/cscl.c:      ppacket* p = eptr->inpacket;
./cs/cscl.c:      eptr->inpacket = eptr->inpacket->next;
./cs/cscl.c:      if(eptr->inpacket == NULL){
./cs/cscl.c:        eptr->mode = HEADER;
./cs/cscl.c:        eptr->startptr = eptr->headbuf;
./cs/cscl.c:        eptr->bytesleft = HEADER_LEN;
./cs/cscl.c:  while(eptr->outpacket){
./cs/cscl.c:		i=write(eptr->sock,eptr->outpacket->startptr,eptr->outpacket->bytesleft);
./cs/cscl.c:				mfs_arg_errlog_silent(LOG_NOTICE,"cscl module: (ip:%u.%u.%u.%u) write error",(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./cs/cscl.c:				eptr->mode = KILL;
./cs/cscl.c:    fprintf(stderr,"wrote %d to (ip:%u.%u.%u.%u)\n",i,(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./cs/cscl.c:		eptr->outpacket->startptr += i;
./cs/cscl.c:		eptr->outpacket->bytesleft -=i;
./cs/cscl.c:    if(eptr->outpacket->bytesleft > 0) return;
./cs/cscl.c:    ppacket* p = eptr->outpacket;
./cs/cscl.c:    eptr->outpacket = eptr->outpacket->next;
./cs/cscl.c:    outp->next = eptr->outpacket;
./cs/cscl.c:    eptr->outpacket = outp;
./cs/cscl.c:    outp->next = eptr->outpacket;
./cs/cscl.c:    eptr->outpacket = outp;
./echo/echo.c:			eptr->next = echoservhead;
./echo/echo.c:			eptr->sock = ns;
./echo/echo.c:			eptr->pdescpos = -1;
./echo/echo.c:			tcpgetpeer(ns,&(eptr->peerip),NULL);
./echo/echo.c:			eptr->mode = DATA;
./echo/echo.c:	for (eptr=echoservhead ; eptr ; eptr=eptr->next) {
./echo/echo.c:		if (eptr->pdescpos>=0) {
./echo/echo.c:			if (pdesc[eptr->pdescpos].revents & (POLLERR|POLLHUP)) {
./echo/echo.c:				eptr->mode = KILL;
./echo/echo.c:			if ((pdesc[eptr->pdescpos].revents & POLLIN) && eptr->mode!=KILL) {
./echo/echo.c:	for (eptr=echoservhead ; eptr ; eptr=eptr->next) {
./echo/echo.c:		if (eptr->pdescpos>=0) {
./echo/echo.c:			if ((((pdesc[eptr->pdescpos].events & POLLOUT)==0 && (eptr->writelen!=0)) || (pdesc[eptr->pdescpos].revents & POLLOUT)) && eptr->mode!=KILL) {
./echo/echo.c:		if (eptr->mode == KILL) {
./echo/echo.c:			tcpclose(eptr->sock);
./echo/echo.c:			*kptr = eptr->next;
./echo/echo.c:			kptr = &(eptr->next);
./echo/echo.c:	for(eptr=echoservhead ; eptr ; eptr=eptr->next){
./echo/echo.c:		pdesc[pos].fd = eptr->sock;
./echo/echo.c:		eptr->pdescpos = pos;
./echo/echo.c:		if (eptr->writelen != 0) {
./echo/echo.c:		eptrn = eptr->next;
./echo/echo.c:  char* buf = eptr->buffer;
./echo/echo.c:  int len = sizeof(eptr->buffer);
./echo/echo.c:		i=read(eptr->sock,buf,len);
./echo/echo.c:      fprintf(stderr,"connection with client(ip:%u.%u.%u.%u) has been closed by peer\n",(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./echo/echo.c:			eptr->mode = KILL;
./echo/echo.c:				eptr->mode = KILL;
./echo/echo.c:      fprintf(stderr,"read %d from (ip:%u.%u.%u.%u)\n",writelen,(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./echo/echo.c:      eptr->writelen = writelen;
./echo/echo.c:  char* buf = eptr->buffer;
./echo/echo.c:  int len = eptr->writelen;
./echo/echo.c:		i=write(eptr->sock,buf,len);
./echo/echo.c:				mfs_arg_errlog_silent(LOG_NOTICE,"main master server module: (ip:%u.%u.%u.%u) write error",(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./echo/echo.c:        eptr->writelen = 0;
./echo/echo.c:				eptr->mode = KILL;
./echo/echo.c:      fprintf(stderr,"wrote %d from (ip:%u.%u.%u.%u)\n",eptr->writelen,(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./echo/echo.c:      eptr->writelen = 0;
Binary file ./mis/.mis.c.swp matches
./mis/mis.c:    //nf->srcip = eptr->peerip;
./mis/mis.c:			eptr->next = misservhead;
./mis/mis.c:			eptr->sock = ns;
./mis/mis.c:			eptr->pdescpos = -1;
./mis/mis.c:			tcpgetpeer(ns,&(eptr->peerip),NULL);
./mis/mis.c:			eptr->mode = HEADER;
./mis/mis.c:      eptr->inpacket = NULL;
./mis/mis.c:      eptr->outpacket = NULL;
./mis/mis.c:      eptr->bytesleft = HEADER_LEN;
./mis/mis.c:      eptr->startptr = eptr->headbuf;
./mis/mis.c:      fprintf(stderr,"mds(ip:%u.%u.%u.%u) connected\n",(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./mis/mis.c:	for (eptr=misservhead ; eptr ; eptr=eptr->next) {
./mis/mis.c:		if (eptr->pdescpos>=0) {
./mis/mis.c:			if (pdesc[eptr->pdescpos].revents & (POLLERR|POLLHUP)) {
./mis/mis.c:				eptr->mode = KILL;
./mis/mis.c:			if ((pdesc[eptr->pdescpos].revents & POLLIN) && eptr->mode!=KILL) {
./mis/mis.c:	for (eptr=misservhead ; eptr ; eptr=eptr->next) {
./mis/mis.c:		if (eptr->pdescpos>=0) {
./mis/mis.c:			if ((((pdesc[eptr->pdescpos].events & POLLOUT)==0 && (eptr->outpacket!=NULL)) || (pdesc[eptr->pdescpos].revents & POLLOUT)) && eptr->mode!=KILL) {
./mis/mis.c:		if (eptr->mode == KILL) {
./mis/mis.c:			tcpclose(eptr->sock);
./mis/mis.c:			*kptr = eptr->next;
./mis/mis.c:			kptr = &(eptr->next);
./mis/mis.c:	for(eptr=misservhead ; eptr ; eptr=eptr->next){
./mis/mis.c:		pdesc[pos].fd = eptr->sock;
./mis/mis.c:		eptr->pdescpos = pos;
./mis/mis.c:		if (eptr->outpacket != NULL) {
./mis/mis.c:		eptrn = eptr->next;
./mis/mis.c:    for( pp = eptr->inpacket; pp; pp = ppn){
./mis/mis.c:    for( pp = eptr->outpacket; pp; pp = ppn){
./mis/mis.c:    if(eptr->mode == HEADER){
./mis/mis.c:		  i=read(eptr->sock,eptr->startptr,eptr->bytesleft);
./mis/mis.c:      i=read(eptr->sock,eptr->inpacket->startptr,eptr->inpacket->bytesleft);
./mis/mis.c:      fprintf(stderr,"connection with client(ip:%u.%u.%u.%u) has been closed by peer\n",(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./mis/mis.c:			eptr->mode = KILL;
./mis/mis.c:				eptr->mode = KILL;
./mis/mis.c:    fprintf(stderr,"read %d from (ip:%u.%u.%u.%u)\n",i,(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./mis/mis.c:    if(eptr->mode == HEADER){
./mis/mis.c:      eptr->bytesleft -= i;
./mis/mis.c:      eptr->startptr += i;
./mis/mis.c:      if(eptr->bytesleft > 0) return;
./mis/mis.c:      const uint8_t *pptr = eptr->headbuf;
./mis/mis.c:      inp->next = eptr->inpacket;
./mis/mis.c:      eptr->inpacket = inp;
./mis/mis.c:      eptr->mode = DATA;
./mis/mis.c:      eptr->inpacket->bytesleft -= i;
./mis/mis.c:      eptr->inpacket->startptr += i;
./mis/mis.c:      if(eptr->inpacket->bytesleft > 0) return;
./mis/mis.c:      eptr->inpacket->startptr = eptr->inpacket->buf;
./mis/mis.c:      fprintf(stderr,"packet received,size=%d,cmd=%X\n",eptr->inpacket->size,eptr->inpacket->cmd);
./mis/mis.c:      mis_gotpacket(eptr,eptr->inpacket);
./mis/mis.c:      ppacket* p = eptr->inpacket;
./mis/mis.c:      eptr->inpacket = eptr->inpacket->next;
./mis/mis.c:      if(eptr->inpacket == NULL){
./mis/mis.c:        eptr->mode = HEADER;
./mis/mis.c:        eptr->startptr = eptr->headbuf;
./mis/mis.c:        eptr->bytesleft = HEADER_LEN;
./mis/mis.c:  while(eptr->outpacket){
./mis/mis.c:		i=write(eptr->sock,eptr->outpacket->startptr,eptr->outpacket->bytesleft);
./mis/mis.c:				mfs_arg_errlog_silent(LOG_NOTICE,"mis module: (ip:%u.%u.%u.%u) write error",(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./mis/mis.c:				eptr->mode = KILL;
./mis/mis.c:    fprintf(stderr,"wrote %d from (ip:%u.%u.%u.%u)\n",i,(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./mis/mis.c:		eptr->outpacket->startptr += i;
./mis/mis.c:		eptr->outpacket->bytesleft -=i;
./mis/mis.c:    if(eptr->outpacket->bytesleft > 0) return;
./mis/mis.c:    ppacket* p = eptr->outpacket;
./mis/mis.c:    eptr->outpacket = eptr->outpacket->next;
./mis/mis.c:  p->next = eptr->outpacket;
./mis/mis.c:  eptr->outpacket = p;
./mis/mis.c:  p->next = eptr->outpacket;
./mis/mis.c:  eptr->outpacket = p;
./mis/mis.c:    nf->srcip = eptr->peerip; //not necessary for dir
./mis/mis.c:  p->next = eptr->outpacket;
./mis/mis.c:  eptr->outpacket = p;
./mis/mis.c:  p->next = eptr->outpacket;
./mis/mis.c:  eptr->outpacket = p;
./mis/mis.c:    if(f->srcip != eptr->peerip){//update mds info
./mis/mis.c:        outp->next = ceptr->outpacket;
./mis/mis.c:        ceptr->outpacket = outp;
./mis/mis.c:  p->next = eptr->outpacket;
./mis/mis.c:  eptr->outpacket = p;
./mis/mis.c:    nf->srcip = eptr->peerip;
./mis/mis.c:  p->next = eptr->outpacket;
./mis/mis.c:  eptr->outpacket = p;
./mis/mis.c:  p->next = eptr->outpacket;
./mis/mis.c:  eptr->outpacket = p;
./mis/mis.c:  p->next = eptr->outpacket;
./mis/mis.c:  eptr->outpacket = p;
./mis/mis.c:    fprintf(stderr,"peerip=%X\n",eptr->peerip);
./mis/mis.c:    if(eptr->peerip == ip)
./mis/mis.c:    eptr = eptr->next;
./mis/mis.c:    if(f->srcip != eptr->peerip){//update mds info
./mis/mis.c:        outp->next = ceptr->outpacket;
./mis/mis.c:        ceptr->outpacket = outp;
./mis/mis.c:  p->next = eptr->outpacket;
./mis/mis.c:  eptr->outpacket = p;
./mis/mis.c:    if(f->srcip != eptr->peerip){//update mds info
./mis/mis.c:        outp->next = ceptr->outpacket;
./mis/mis.c:        ceptr->outpacket = outp;
./mis/mis.c:  p->next = eptr->outpacket;
./mis/mis.c:  eptr->outpacket = p;
./mis/mis.c:    if(f->srcip != eptr->peerip){//update mds info
./mis/mis.c:        outp->next = ceptr->outpacket;
./mis/mis.c:        ceptr->outpacket = outp;
./mis/mis.c:  p->next = eptr->outpacket;
./mis/mis.c:  eptr->outpacket = p;
./mis/mis.c:    outp->next = eptr->outpacket;
./mis/mis.c:    eptr->outpacket = outp;
./mis/mis.c:      put32bit(&ptr2,eptr->peerip);
./mis/mis.c:      outp->next = ceptr->outpacket;
./mis/mis.c:      ceptr->outpacket = outp;
./mis/mis.c:    fprintf(stderr,"forwarding peerip=%X\n",eptr->peerip);
./mis/mis.c:    put32bit(&ptr2,eptr->peerip);//remote mds
./mis/mis.c:  outp->next = ceptr->outpacket;
./mis/mis.c:  ceptr->outpacket = outp;
./mds/mds.c:	eptr->sock = msock;
./mds/mds.c:	eptr->pdescpos = -1;
./mds/mds.c:  eptr->peerip = misip;
./mds/mds.c:  eptr->mode = HEADER;
./mds/mds.c:  eptr->inpacket = NULL;
./mds/mds.c:  eptr->outpacket = NULL;
./mds/mds.c:  eptr->bytesleft = HEADER_LEN;
./mds/mds.c:  eptr->startptr = eptr->headbuf;
./mds/mds.c:			eptr->next = mdsservhead;
./mds/mds.c:			eptr->sock = ns;
./mds/mds.c:			eptr->pdescpos = -1;
./mds/mds.c:			tcpgetpeer(ns,&(eptr->peerip),NULL);
./mds/mds.c:			eptr->mode = HEADER;
./mds/mds.c:      eptr->inpacket = NULL;
./mds/mds.c:      eptr->outpacket = NULL;
./mds/mds.c:      eptr->bytesleft = HEADER_LEN;
./mds/mds.c:      eptr->startptr = eptr->headbuf;
./mds/mds.c:      fprintf(stderr,"client(ip:%u.%u.%u.%u) connected\n",(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./mds/mds.c:  if (eptr->pdescpos>=0) {
./mds/mds.c:    if (pdesc[eptr->pdescpos].revents & (POLLERR|POLLHUP)) {
./mds/mds.c:      eptr->mode = KILL;
./mds/mds.c:    if ((pdesc[eptr->pdescpos].revents & POLLIN) && eptr->mode!=KILL) {
./mds/mds.c:  if (eptr->pdescpos>=0) {
./mds/mds.c:    if ((((pdesc[eptr->pdescpos].events & POLLOUT)==0 && (eptr->outpacket!=NULL)) || (pdesc[eptr->pdescpos].revents & POLLOUT)) && eptr->mode!=KILL) {
./mds/mds.c:	for (eptr=mdsservhead ; eptr ; eptr=eptr->next) {
./mds/mds.c:		if (eptr->pdescpos>=0) {
./mds/mds.c:			if (pdesc[eptr->pdescpos].revents & (POLLERR|POLLHUP)) {
./mds/mds.c:				eptr->mode = KILL;
./mds/mds.c:			if ((pdesc[eptr->pdescpos].revents & POLLIN) && eptr->mode!=KILL) {
./mds/mds.c:	for (eptr=mdsservhead ; eptr ; eptr=eptr->next) {
./mds/mds.c:		if (eptr->pdescpos>=0) {
./mds/mds.c:			if ((((pdesc[eptr->pdescpos].events & POLLOUT)==0 && (eptr->outpacket!=NULL)) || (pdesc[eptr->pdescpos].revents & POLLOUT)) && eptr->mode!=KILL) {
./mds/mds.c:        if (eptr->mode == KILL) {
./mds/mds.c:            tcpclose(eptr->sock);
./mds/mds.c:            for( pp = eptr->inpacket; pp; pp = ppn){
./mds/mds.c:            for( pp = eptr->outpacket; pp; pp = ppn){
./mds/mds.c:            *kptr = eptr->next;
./mds/mds.c:            kptr = &(eptr->next);
./mds/mds.c:	for(eptr=mdsservhead ; eptr ; eptr=eptr->next){
./mds/mds.c:		pdesc[pos].fd = eptr->sock;
./mds/mds.c:		eptr->pdescpos = pos;
./mds/mds.c:		if (eptr->outpacket != NULL) {
./mds/mds.c:  pdesc[pos].fd = eptr->sock;
./mds/mds.c:  eptr->pdescpos = pos;
./mds/mds.c:  if (eptr->outpacket != NULL) {
./mds/mds.c:		eptrn = eptr->next;
./mds/mds.c:    for( pp = eptr->inpacket; pp; pp = ppn){
./mds/mds.c:    for( pp = eptr->outpacket; pp; pp = ppn){
./mds/mds.c:    eptrn = eptr->next;
./mds/mds.c:    for( pp = eptr->inpacket; pp; pp = ppn){
./mds/mds.c:    for( pp = eptr->outpacket; pp; pp = ppn){
./mds/mds.c:    if(eptr->mode == HEADER){
./mds/mds.c:		  i=read(eptr->sock,eptr->startptr,eptr->bytesleft);
./mds/mds.c:      i=read(eptr->sock,eptr->inpacket->startptr,eptr->inpacket->bytesleft);
./mds/mds.c:      fprintf(stderr,"connection with client(ip:%u.%u.%u.%u) has been closed by peer\n",(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./mds/mds.c:			eptr->mode = KILL;
./mds/mds.c:				eptr->mode = KILL;
./mds/mds.c:    fprintf(stderr,"read %d from (ip:%u.%u.%u.%u)\n",i,(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./mds/mds.c:    if(eptr->mode == HEADER){
./mds/mds.c:      eptr->bytesleft -= i;
./mds/mds.c:      eptr->startptr += i;
./mds/mds.c:      if(eptr->bytesleft > 0) return;
./mds/mds.c:      const uint8_t *pptr = eptr->headbuf;
./mds/mds.c:        id = eptr->peerip;
./mds/mds.c:      inp->next = eptr->inpacket;
./mds/mds.c:      eptr->inpacket = inp;
./mds/mds.c:      eptr->mode = DATA;
./mds/mds.c:      eptr->inpacket->bytesleft -= i;
./mds/mds.c:      eptr->inpacket->startptr += i;
./mds/mds.c:      if(eptr->inpacket->bytesleft > 0) return;
./mds/mds.c:      eptr->inpacket->startptr = eptr->inpacket->buf;
./mds/mds.c:      fprintf(stderr,"packet received,size=%d,cmd=%X,id=%d\n",eptr->inpacket->size,eptr->inpacket->cmd,eptr->inpacket->id);
./mds/mds.c:      mds_gotpacket(eptr,eptr->inpacket);
./mds/mds.c:      ppacket* p = eptr->inpacket;
./mds/mds.c:      eptr->inpacket = eptr->inpacket->next;
./mds/mds.c:      if(eptr->inpacket == NULL){
./mds/mds.c:        eptr->mode = HEADER;
./mds/mds.c:        eptr->startptr = eptr->headbuf;
./mds/mds.c:        eptr->bytesleft = HEADER_LEN;
./mds/mds.c:  while(eptr->outpacket){
./mds/mds.c:		i=write(eptr->sock,eptr->outpacket->startptr,eptr->outpacket->bytesleft);
./mds/mds.c:				mfs_arg_errlog_silent(LOG_NOTICE,"mds: (ip:%u.%u.%u.%u) write error",(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./mds/mds.c:				eptr->mode = KILL;
./mds/mds.c:    fprintf(stderr,"wrote %d from (ip:%u.%u.%u.%u)\n",i,(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./mds/mds.c:		eptr->outpacket->startptr += i;
./mds/mds.c:		eptr->outpacket->bytesleft -=i;
./mds/mds.c:    if(eptr->outpacket->bytesleft > 0) return;
./mds/mds.c:    ppacket* p = eptr->outpacket;
./mds/mds.c:    eptr->outpacket = eptr->outpacket->next;
./mds/mds.c:    if(eptr->peerip == id)
./mds/mds.c:    eptr = eptr->next;
./mds/mds.c:    outp->next = ceptr->outpacket;
./mds/mds.c:    ceptr->outpacket = outp;
./mds/mds.c:    outp->next = eptr->outpacket;
./mds/mds.c:    eptr->outpacket = outp;
./mds/mds.c:        outp->next = eptr->outpacket;
./mds/mds.c:        eptr->outpacket = outp;
./mds/mds.c:    outp->next = eptr->outpacket;
./mds/mds.c:    eptr->outpacket = outp;
./mds/mds.c:    outp->next = eptr->outpacket;
./mds/mds.c:    eptr->outpacket = outp;
./mds/mds.c:    outp->next = eptr->outpacket;
./mds/mds.c:    eptr->outpacket = outp;
./mds/mds.c:        outp2->next = eptr->outpacket;
./mds/mds.c:        eptr->outpacket = outp2;
./mds/mds.c:        nf->srcip = eptr->peerip;
./mds/mds.c:        outp2->next = eptr->outpacket;
./mds/mds.c:        eptr->outpacket = outp2;
./mds/mds.c:        nf->srcip = eptr->peerip;
./mds/mds.c:    outp->next = eptr->outpacket;
./mds/mds.c:    eptr->outpacket = outp;
./mds/mds.c:    outp->next = eptr->outpacket;
./mds/mds.c:    eptr->outpacket = outp;
./mds/mds.c:    outp->next = eptr->outpacket;
./mds/mds.c:    eptr->outpacket = outp;
./mds/mds.c:    outp->next = eptr->outpacket;
./mds/mds.c:    eptr->outpacket = outp;
./mds/mdscs.c:			eptr->next = mdscsservhead;
./mds/mdscs.c:			eptr->sock = ns;
./mds/mdscs.c:			eptr->pdescpos = -1;
./mds/mdscs.c:			tcpgetpeer(ns,&(eptr->peerip),NULL);
./mds/mdscs.c:			eptr->mode = HEADER;
./mds/mdscs.c:      eptr->inpacket = NULL;
./mds/mdscs.c:      eptr->outpacket = NULL;
./mds/mdscs.c:      eptr->bytesleft = HEADER_LEN;
./mds/mdscs.c:      eptr->startptr = eptr->headbuf;
./mds/mdscs.c:      eptr->clist = NULL;
./mds/mdscs.c:      eptr->chunks = eptr->availspace = eptr->space = -1;
./mds/mdscs.c:      fprintf(stderr,"cs(ip:%u.%u.%u.%u) connected\n",(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./mds/mdscs.c:	for (eptr=mdscsservhead ; eptr ; eptr=eptr->next) {
./mds/mdscs.c:		if (eptr->pdescpos>=0) {
./mds/mdscs.c:			if (pdesc[eptr->pdescpos].revents & (POLLERR|POLLHUP)) {
./mds/mdscs.c:				eptr->mode = KILL;
./mds/mdscs.c:			if ((pdesc[eptr->pdescpos].revents & POLLIN) && eptr->mode!=KILL) {
./mds/mdscs.c:	for (eptr=mdscsservhead ; eptr ; eptr=eptr->next) {
./mds/mdscs.c:		if (eptr->pdescpos>=0) {
./mds/mdscs.c:			if ((((pdesc[eptr->pdescpos].events & POLLOUT)==0 && (eptr->outpacket!=NULL)) || (pdesc[eptr->pdescpos].revents & POLLOUT)) && eptr->mode!=KILL) {
./mds/mdscs.c:		if (eptr->mode == KILL) {
./mds/mdscs.c:			tcpclose(eptr->sock);
./mds/mdscs.c:			*kptr = eptr->next;
./mds/mdscs.c:			kptr = &(eptr->next);
./mds/mdscs.c:	for(eptr=mdscsservhead ; eptr ; eptr=eptr->next){
./mds/mdscs.c:		pdesc[pos].fd = eptr->sock;
./mds/mdscs.c:		eptr->pdescpos = pos;
./mds/mdscs.c:		if (eptr->outpacket != NULL) {
./mds/mdscs.c:		eptrn = eptr->next;
./mds/mdscs.c:    for( pp = eptr->inpacket; pp; pp = ppn){
./mds/mdscs.c:    for( pp = eptr->outpacket; pp; pp = ppn){
./mds/mdscs.c:    if(eptr->mode == HEADER){
./mds/mdscs.c:		  i=read(eptr->sock,eptr->startptr,eptr->bytesleft);
./mds/mdscs.c:      i=read(eptr->sock,eptr->inpacket->startptr,eptr->inpacket->bytesleft);
./mds/mdscs.c:      fprintf(stderr,"connection with cs(ip:%u.%u.%u.%u) has been closed by peer\n",(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./mds/mdscs.c:			eptr->mode = KILL;
./mds/mdscs.c:				eptr->mode = KILL;
./mds/mdscs.c:    fprintf(stderr,"read %d from (ip:%u.%u.%u.%u)\n",i,(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./mds/mdscs.c:    if(eptr->mode == HEADER){
./mds/mdscs.c:      eptr->bytesleft -= i;
./mds/mdscs.c:      eptr->startptr += i;
./mds/mdscs.c:      if(eptr->bytesleft > 0) return;
./mds/mdscs.c:      const uint8_t *pptr = eptr->headbuf;
./mds/mdscs.c:      inp->next = eptr->inpacket;
./mds/mdscs.c:      eptr->inpacket = inp;
./mds/mdscs.c:      eptr->mode = DATA;
./mds/mdscs.c:      eptr->inpacket->bytesleft -= i;
./mds/mdscs.c:      eptr->inpacket->startptr += i;
./mds/mdscs.c:      if(eptr->inpacket->bytesleft > 0) return;
./mds/mdscs.c:      eptr->inpacket->startptr = eptr->inpacket->buf;
./mds/mdscs.c:      fprintf(stderr,"packet received,size=%d,cmd=%X\n",eptr->inpacket->size,eptr->inpacket->cmd);
./mds/mdscs.c:      mdscs_gotpacket(eptr,eptr->inpacket);
./mds/mdscs.c:      ppacket* p = eptr->inpacket;
./mds/mdscs.c:      eptr->inpacket = eptr->inpacket->next;
./mds/mdscs.c:      if(eptr->inpacket == NULL){
./mds/mdscs.c:        eptr->mode = HEADER;
./mds/mdscs.c:        eptr->startptr = eptr->headbuf;
./mds/mdscs.c:        eptr->bytesleft = HEADER_LEN;
./mds/mdscs.c:  while(eptr->outpacket){
./mds/mdscs.c:		i=write(eptr->sock,eptr->outpacket->startptr,eptr->outpacket->bytesleft);
./mds/mdscs.c:				mfs_arg_errlog_silent(LOG_NOTICE,"mdscs module: (ip:%u.%u.%u.%u) write error",(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./mds/mdscs.c:				eptr->mode = KILL;
./mds/mdscs.c:    fprintf(stderr,"wrote %d to (ip:%u.%u.%u.%u)\n",i,(eptr->peerip>>24)&0xFF,(eptr->peerip>>16)&0xFF,(eptr->peerip>>8)&0xFF,eptr->peerip&0xFF);
./mds/mdscs.c:		eptr->outpacket->startptr += i;
./mds/mdscs.c:		eptr->outpacket->bytesleft -=i;
./mds/mdscs.c:    if(eptr->outpacket->bytesleft > 0) return;
./mds/mdscs.c:    ppacket* p = eptr->outpacket;
./mds/mdscs.c:    eptr->outpacket = eptr->outpacket->next;
./mds/mdscs.c:  for(;eptr;eptr = eptr->next)
./mds/mdscs.c:    if(eptr->peerip == c->csip)
./mds/mdscs.c:  for(eptr = mdscsservhead;eptr;eptr = eptr->next){
./mds/mdscs.c:    if(eptr->mode == KILL) continue;
./mds/mdscs.c:    if(eptr->availspace >= CHUNKSIZE){// not considering spatial load balancing among cs servers
./mds/mdscs.c:      mdschunk* ret = new_chunk(global_chunk_counter++,eptr->peerip,0);
./mds/mdscs.c:      outp->next = eptr->outpacket;
./mds/mdscs.c:      eptr->outpacket = outp; //just hope this packet gets to cs server first
./mds/mdscs.c:  for(eptr = mdscsservhead;eptr;eptr = eptr->next){
./mds/mdscs.c:    if(eptr->mode == KILL) continue;
./mds/mdscs.c:    if(eptr->peerip == c->csip){
./mds/mdscs.c:      outp->next = eptr->outpacket;
./mds/mdscs.c:      eptr->outpacket = outp;
./mds/mdscs.c:      p->next = ceptr->outpacket;
./mds/mdscs.c:      ceptr->outpacket = p;
./mds/mdscs.c:  eptr->space = get32bit(&ptr);
./mds/mdscs.c:  eptr->availspace = get32bit(&ptr);
./mds/mdscs.c:  eptr->chunks = get32bit(&ptr);
./mds/mdscs.c:  for(i=0;i<eptr->chunks;i++){
./mds/mdscs.c:    mdschunk* c = new_chunk(chunkid,eptr->peerip,occupy);
./mds/mdscs.c:    l->next = eptr->clist;
./mds/mdscs.c:    eptr->clist = l;
./mds/mdscs.c:  outp->next = eptr->outpacket;
./mds/mdscs.c:  eptr->outpacket = outp;
./mds/mdscs.c:  eptr->space = get32bit(&ptr);
./mds/mdscs.c:  eptr->availspace = get32bit(&ptr);
./mds/mdscs.c:  eptr->chunks = get32bit(&ptr);
Binary file ./mds/.mds.c.swp matches
